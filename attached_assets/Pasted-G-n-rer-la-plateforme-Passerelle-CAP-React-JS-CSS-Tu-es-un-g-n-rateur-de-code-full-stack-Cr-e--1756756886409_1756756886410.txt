Générer la plateforme “Passerelle CAP” (React/JS/CSS)

Tu es un générateur de code full-stack. Crée une application de production nommée Passerelle CAP (plateforme de gestion des fiches navettes CAP) avec React + JavaScript + CSS (pas de TypeScript, pas de Tailwind). Livre un projet exécutable avec données de démo, scripts, migrations et un README clair.

0) Stack & conventions

Frontend : React 18 + React Router 6, JavaScript pur (ES2022), CSS Modules (ou SCSS Modules si utile), icônes lucide-react.

Backend : Node.js + Express (API REST), validations Yup/Joi, hash bcrypt, sessions via cookies HTTPOnly (JWT signé côté serveur).

DB/ORM : PostgreSQL + Prisma (schéma, migrations, seed) — utilisation en JavaScript.

Data fetching : React Query.

Build : Vite (frontend) + nodemon (backend dev).

Tests : quelques tests Playwright pour les flux critiques.

Scripts : dev:client, dev:server, dev (concurrent), build, start, db:migrate, db:seed, db:reset.

Docker : docker-compose.yml (app server + postgres).

Uploads : dossier local /uploads (prévoir adaptateur S3 ultérieur, non requis ici).

Logging & audit : middleware Express + table AuditLog.

1) Rôles & droits (RBAC)

RBAC strict (middleware Express côté serveur + guards côté client) :

ADMIN : gestion utilisateurs, rôles, EPSI, EVS/CS, ateliers, paramètres; accès total.

SUIVI_PROJETS : lecture seule globale.

EMETTEUR (TAS/FEVES) : crée/édite fiches navettes (brouillon → envoyée FEVES), upload de justificatifs.

RELATIONS_EVS (FEVES) : réceptionne, affecte un EVS/CS, gère contrats, déclenche paiements 70/30, planifie vérifs, clôture.

EVS_CS : reçoit, accepte/refuse/demande infos, signe contrat, confirme réalisation, alimente le suivi.

Terminologie à respecter : fiche navette (jamais “fiche valise”).

2) Cycle de vie (machine d’états)

DRAFT → SUBMITTED_TO_FEVES → ASSIGNED_TO_EVS → EVS_ACCEPTED | EVS_REJECTED | NEEDS_INFO →
si accepté : CONTRACT_SENT → CONTRACT_SIGNED → ADVANCE_70_PAID → ACTIVITY_DONE → FIELD_CHECK_SCHEDULED → FIELD_CHECK_DONE → FINAL_REPORT_RECEIVED → REMAINING_30_PAID → CLOSED → ARCHIVED

Transitions par rôle autorisé uniquement.

Chaque transition écrit un AuditLog (actorId, timestamp, old/new state, metadata).

3) Modèle de données (Prisma, JS)

Créer migrations Prisma. Champs + index + FKs. (Même modèle que ci-dessous, en JavaScript.)

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String
  firstName     String
  lastName      String
  role          Role
  epsiId        String?
  orgId         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  auditLogs     AuditLog[]
}

enum Role { ADMIN SUIVI_PROJETS EMETTEUR RELATIONS_EVS EVS_CS }

model EPSI {
  id   String @id @default(cuid())
  name String @unique
  orgs Organization[]
}

model Organization { // EVS/CS
  id       String @id @default(cuid())
  name     String
  type     OrgType
  address  String?
  contact  String?
  email    String?
  phone    String?
  epsiId   String
  epsi     EPSI    @relation(fields: [epsiId], references: [id])
  users    User[]
  workshops  Workshop[]
  fiches   FicheNavette[] @relation("OrgFiches")
}
enum OrgType { EVS CS }

model Family {
  id       String   @id @default(cuid())
  code     String   @unique
  address  String?
  phone    String?
  email    String?
  mother   String?
  father   String?
  guardian String?
  children Child[]
  notes    String?
  fiches   FicheNavette[]
}

model Child {
  id        String   @id @default(cuid())
  familyId  String
  firstName String?
  birthDate DateTime?
  level     String?
  family    Family  @relation(fields: [familyId], references: [id])
}

model WorkshopObjective {
  id    String @id @default(cuid())
  code  String @unique // OBJ1/OBJ2/OBJ3
  name  String
  order Int
  workshops Workshop[]
}

model Workshop {
  id          String @id @default(cuid())
  objectiveId String
  name        String
  description String?
  priceCents  Int
  orgId       String?
  objective   WorkshopObjective @relation(fields: [objectiveId], references: [id])
  organization Organization?    @relation(fields: [orgId], references: [id])
}

model FicheNavette {
  id            String         @id @default(cuid())
  ref           String         @unique
  state         FicheState
  emitterId     String
  familyId      String
  assignedOrgId String?
  epsiId        String?
  description   String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  emitter       User           @relation(fields: [emitterId], references: [id])
  family        Family         @relation(fields: [familyId], references: [id])
  assignedOrg   Organization?  @relation("OrgFiches", fields: [assignedOrgId], references: [id])
  epsi          EPSI?          @relation(fields: [epsiId], references: [id])

  selections    FicheWorkshopSelection[]
  attachments   Attachment[]
  contract      Contract?
  payments      Payment[]
  verification  FieldVerification?
  finalReport   FinalReport?
}

enum FicheState {
  DRAFT SUBMITTED_TO_FEVES ASSIGNED_TO_EVS EVS_ACCEPTED EVS_REJECTED NEEDS_INFO
  CONTRACT_SENT CONTRACT_SIGNED ADVANCE_70_PAID ACTIVITY_DONE FIELD_CHECK_SCHEDULED
  FIELD_CHECK_DONE FINAL_REPORT_RECEIVED REMAINING_30_PAID CLOSED ARCHIVED
}

model FicheWorkshopSelection {
  id         String  @id @default(cuid())
  ficheId    String
  workshopId String
  qty        Int     @default(1)
  fiche      FicheNavette @relation(fields: [ficheId], references: [id])
  workshop   Workshop     @relation(fields: [workshopId], references: [id])
}

model Contract {
  id          String   @id @default(cuid())
  ficheId     String   @unique
  orgSigned   Boolean  @default(false)
  fevesSigned Boolean  @default(false)
  signedAt    DateTime?
  fileUrl     String?
  fiche       FicheNavette @relation(fields: [ficheId], references: [id])
}

model Payment {
  id          String   @id @default(cuid())
  ficheId     String
  kind        PaymentKind
  amountCents Int
  paid        Boolean @default(false)
  paidAt      DateTime?
  fiche       FicheNavette @relation(fields: [ficheId], references: [id])
}
enum PaymentKind { ADVANCE_70 REMAINING_30 }

model FieldVerification {
  id          String   @id @default(cuid())
  ficheId     String   @unique
  scheduledAt DateTime?
  doneAt      DateTime?
  reportUrl   String?
  fiche       FicheNavette @relation(fields: [ficheId], references: [id])
}

model FinalReport {
  id             String   @id @default(cuid())
  ficheId        String   @unique
  evaluation     String?
  difficulties   String?
  recommendations String?
  fileUrl        String?
  fiche          FicheNavette @relation(fields: [ficheId], references: [id])
}

model Attachment {
  id         String   @id @default(cuid())
  ficheId    String
  name       String
  mime       String
  url        String
  uploadedBy String
  createdAt  DateTime @default(now())
  fiche      FicheNavette @relation(fields: [ficheId], references: [id])
}

model AuditLog {
  id        String   @id @default(cuid())
  actorId   String?
  action    String
  entity    String
  entityId  String
  meta      Json?
  createdAt DateTime @default(now())
  actor     User?    @relation(fields: [actorId], references: [id])
}

Seed (données de démo)

6 EPSI, 12 Organizations (EVS/CS) réparties.

3 Objectives : OBJ1 (compétences parentales), OBJ2 (communication intergénérationnelle), OBJ3 (dynamiques par le sport).

Workshops par objectif d’après la fiche navette (avec priceCents).

Comptes de démo : 1 ADMIN (admin@passerelle.cap / Admin!234) + 1 par rôle.

3 familles + 5 enfants.

3 fiches navettes à différents états.

4) Écrans (React Router)

/login : Email + mot de passe → cookie HTTPOnly (JWT) ; feedback erreurs.

/ (dashboard) :

KPI (cartes sobres) + liste des fiches filtrable (État, EPSI, EVS/CS, période, objectif).

Vues par rôle (EMETTEUR : “Mes fiches” + bouton Nouvelle fiche navette ; RELATIONS_EVS : files d’attente à affecter / à payer / à vérifier ; EVS_CS : “Fiches reçues/en cours” ; SUIVI_PROJETS : lecture globale ; ADMIN : liens d’admin + KPIs globaux).

/fiches/new (EMETTEUR) : formulaire Fiche Navette – CAP (sections : Référent, Infos famille, Description, Sélection d’ateliers par Objectif OBJ1/2/3, uploads). Boutons Sauvegarder brouillon / Envoyer FEVES.

/fiches/:id : fiche détaillée avec timeline d’état, métadonnées, ateliers (quantité, prix), pièces jointes, commentaires internes, journal d’audit.

RELATIONS_EVS : Affecter EVS/CS (filtre EPSI + compatibilité ateliers) ; Générer contrat (PDF) ; Envoyer contrat ; Valider paiement 70% ; Programmer vérification ; Valider paiement 30% ; Clôturer ; Archiver.

EVS_CS : Accepter / Refuser / Demande d’infos ; Signer (e-signature légère : case + nom + horodatage) ; Confirmer activité réalisée ; upload rapport si demandé.

EMETTEUR : lecture + commentaires ; édition si DRAFT.

/admin :

Utilisateurs (CRUD, rôle, EPSI, org)

EPSI (CRUD)

EVS/CS (CRUD + rattachement EPSI)

Ateliers & Objectifs (CRUD + prix)

Paramètres (modèles de contrat, textes)

/reports : exports CSV/PDF (familles aidées, montants par EVS/CS, nb d’ateliers par objectif, temps de cycle).

5) API Express (REST)

Auth : POST /api/auth/login, POST /api/auth/logout, GET /api/auth/me

Fiches :

GET /api/fiches (filtrable), POST /api/fiches

GET /api/fiches/:id, PATCH /api/fiches/:id

POST /api/fiches/:id/transition (vérifie rôle + état et écrit AuditLog)

POST /api/fiches/:id/assign (RELATIONS_EVS)

Contrat : POST /api/fiches/:id/contract/generate (PDF serveur simple), POST /api/fiches/:id/contract/sign (EVS/CS), POST /api/fiches/:id/contract/feves-sign

Paiements : POST /api/fiches/:id/pay/advance, POST /api/fiches/:id/pay/remain (MVP : enregistre preuve/état)

Vérif terrain : POST /api/fiches/:id/field/schedule, POST /api/fiches/:id/field/complete

Rapport final : POST /api/fiches/:id/final-report

Référentiels : GET/CRUD /api/epsi, /api/orgs, /api/workshops, /api/objectives

Uploads : POST /api/uploads → stock local /uploads (filtre MIME PDF/JPG/PNG, 10 Mo)

Audit : GET /api/audit?entity=FicheNavette&entityId=...

Toutes les mutations créent un AuditLog.

6) Règles métier

Affectation : seule RELATIONS_EVS assigne une fiche ; EVS/CS voit uniquement ses fiches.

Transitions :

EMETTEUR : DRAFT → SUBMITTED_TO_FEVES.

RELATIONS_EVS : SUBMITTED_TO_FEVES → ASSIGNED_TO_EVS; génération/émission contrat ; paiements ; vérif ; clôture/archivage.

EVS_CS : ASSIGNED_TO_EVS → EVS_ACCEPTED | EVS_REJECTED | NEEDS_INFO; CONTRACT_SENT → CONTRACT_SIGNED; ADVANCE_70_PAID → ACTIVITY_DONE.

Montants : somme(priceCents * qty) des ateliers retenus → 70% puis 30%.

RGPD : accès par rôle ; identification famille par Family.code (anonymisé) ; exports sécurisés.

Pièces : PDF/JPG/PNG, horodatées.

7) Charte graphique (CSS Modules)

Palette désaturée et sobre :

Primaire Bleu-gris #3B4B61 ; Fond doux Gris clair #F5F6F7 ; Blanc #FFFFFF

Succès Vert doux #6A8B74 ; Attente Orange sable #D9A066 ; Erreur Bordeaux #8C4A4A

Typo : système (Inter/Roboto si dispo), base 16px, contrastes AA.
Composants : boutons plats, cards radius 8px, pastilles d’état (vert/orange/bordeaux).
Fournir un fichier src/styles/variables.css avec : couleurs CSS vars, spacing, radius, ombres.

8) UX spécifiques

Timeline statuts sur la fiche.

Filtres (État, EPSI, EVS/CS, période, objectif/atelier).

Exports CSV/PDF dans /reports.

Notifications (MVP : toasts + page Notifications).

Commentaires internes (threads courts) par fiche.

9) Sécurité

Auth par JWT stocké en cookie HTTPOnly (SameSite=Lax).

Rate-limit simple (per-IP) sur endpoints sensibles.

Validation Yup/Joi sur toutes les entrées.

Sanitize (xss, filenames); contrôle rôle/org/epsi sur chaque action serveur.

CORS verrouillé au front.

10) Données de démo & scripts

npm run db:reset → drop, migrate, seed.

Afficher en console les comptes de démo (emails + mdp).

docker-compose up : postgres + serveur API ; front sur Vite.

Scripts :

dev:client (Vite), dev:server (nodemon), dev (concurrently)

build (client + server), start (node dist)

db:migrate, db:seed, db:reset

11) Tests (Playwright, minimum)

Flow complet : EMETTEUR (brouillon → envoi), RELATIONS_EVS (affectation → contrat → 70%), EVS_CS (signature → activité réalisée), RELATIONS_EVS (vérif → 30% → clôture).

Permissions : SUIVI_PROJETS ne peut pas muter ; EVS/CS ne voit que ses fiches.

Audit : mutation → ligne d’audit.

12) README

Inclure : installation, .env.example, scripts, rôles, comptes de démo, carte des pages, et diagramme Mermaid :

flowchart LR
DRAFT -->|Envoyer FEVES| SUBMITTED_TO_FEVES
SUBMITTED_TO_FEVES -->|Affecter EVS/CS| ASSIGNED_TO_EVS
ASSIGNED_TO_EVS -->|Accepter| EVS_ACCEPTED
ASSIGNED_TO_EVS -->|Refuser| EVS_REJECTED
ASSIGNED_TO_EVS -->|Infos| NEEDS_INFO
EVS_ACCEPTED --> CONTRACT_SENT --> CONTRACT_SIGNED --> ADVANCE_70_PAID --> ACTIVITY_DONE --> FIELD_CHECK_SCHEDULED --> FIELD_CHECK_DONE --> FINAL_REPORT_RECEIVED --> REMAINING_30_PAID --> CLOSED --> ARCHIVED


Livrables attendus :

Front React/JS/CSS + API Express prêts à lancer

Prisma schema + migrations + seed OK

Auth avec cookies HTTPOnly et comptes de démo

Pages & API conformes au RBAC et au cycle de vie

Tests Playwright minimaux

README détaillé