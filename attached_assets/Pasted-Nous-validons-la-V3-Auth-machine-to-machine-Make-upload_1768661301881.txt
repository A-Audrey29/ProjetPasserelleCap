Nous validons la V3 â€“ Auth machine-to-machine Make + upload PDF sÃ©curisÃ© + migrations versionnÃ©es.
Ce message sert de rÃ©fÃ©rence unique et dÃ©finitive pour lâ€™implÃ©mentation.

1) Objectif fonctionnel

Permettre Ã  Make de :

crÃ©er une fiche navette uniquement en Ã©tat DRAFT

uploader un PDF signÃ© sur une fiche DRAFT

Sans jamais :

changer lâ€™Ã©tat de la fiche

modifier ou supprimer une fiche

accÃ©der aux autres routes de lâ€™API

2) Authentification

Frontend : cookie auth_token (JWT) â†’ inchangÃ©

Make : header X-API-Key

RÃ¨gles :

Middleware hybride requireAuthOrApiKey

PrioritÃ© au cookie JWT si prÃ©sent

Sinon, validation de X-API-Key

ClÃ©s dÃ©finies via MAKE_API_KEYS (liste sÃ©parÃ©e par virgules)

Injection dâ€™un pseudo-user :

{ userId: "make-integration", role: "INTEGRATION_MAKE", authSource: "API_KEY" }

3) RÃ´le INTEGRATION_MAKE

Autorisations strictes :

âœ… POST /api/fiches â†’ crÃ©ation DRAFT uniquement

âœ… POST /api/fiches/:id/documents â†’ upload PDF si fiche DRAFT

âŒ PATCH / transition / delete / autres routes

RÃ¨gles mÃ©tier :

externalId obligatoire si authSource === API_KEY

state toujours forcÃ© Ã  DRAFT

capDocuments ajoutÃ©s uniquement via la route upload

4) Upload PDF (navettes)

Route :

POST /api/fiches/:id/documents


Contraintes :

PDF uniquement (%PDF- magic bytes)

Taille max : 10 MB

Fiche doit exister et Ãªtre en DRAFT

Upload via uploadNavette() (FTPS â†’ /uploads/navettes/{uuid}.pdf)

Stockage URL relative /uploads/navettes/{uuid}.pdf

Multer :

memoryStorage

Ã©criture temporaire via os.tmpdir()

I/O async (fs.promises)

5) Idempotence (upload)

Header optionnel :

X-Idempotency-Key


Validation :

string

trim

non vide

max 255 chars

sinon â†’ 400 INVALID_IDEMPOTENCY_KEY

Comportement :

mÃªme clÃ© + mÃªme fichier â†’ 200 (retry)

mÃªme clÃ© + fichier diffÃ©rent â†’ 409

Table :

idempotency_keys(key, fiche_id, file_hash, response_json, created_at)


RÃ©tention : 24h
Purge horaire au runtime

6) Rate limiting

Uniquement si X-API-Key prÃ©sent

100 req / 15 min / IP

Fonctionne derriÃ¨re proxy (Render) :

app.set("trust proxy", 1)
keyGenerator: req.ip

7) Logging

Logs JSON structurÃ©s (JAMAIS la clÃ© API) :

route

authSource

userId / role

ficheId / externalId si dispo

status / code

ip

8) Migrations production

Migrations SQL versionnÃ©es dans /migrations

Table schema_migrations

Runner scripts/migrate.ts

RÃ¨gles :

ExÃ©cution AVANT dÃ©marrage serveur

Stop immÃ©diat + exit code â‰  0 si erreur

Pas dâ€™Ã©criture dans schema_migrations en cas dâ€™Ã©chec

Transactions :

migrations normales â†’ transaction

migrations avec CONCURRENTLY â†’ fichier suffixÃ© _notx, exÃ©cutÃ© hors transaction

Build prod :

scripts/migrate.ts compilÃ© via esbuild â†’ dist/migrate.js

npm run start = node dist/migrate.js && node dist/index.js

9) Ã‰tat

ğŸ‘‰ V3 VALIDÃ‰E
ğŸ‘‰ Tu peux lancer lâ€™implÃ©mentation complÃ¨te conformÃ©ment Ã  ce cadrage.

Merci de signaler toute divergence avant commit.